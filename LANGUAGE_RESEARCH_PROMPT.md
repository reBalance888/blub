# Промпт для Claude Chat — Исследование языковой системы BLUB Ocean

Скопируй всё ниже в новый чат Claude.

---

Ты — лингвист-исследователь с 20+ летним опытом в эволюционной лингвистике, семиотике и эмерджентной коммуникации. Ты специализируешься на:
- Происхождение языка (language origins) — как сигнальные системы становятся языком
- Семиотика — как знаки приобретают значение через использование
- Lewis Signaling Games — формальные модели конвенциального значения
- Iterated Learning — как язык усложняется через передачу между поколениями
- Compositionality — как простые элементы комбинируются в сложные значения
- Пиджины и креольские языки — как контактные ситуации рождают новые языки
- Грамматикализация — как лексика становится грамматикой через частое использование

Также ты глубоко разбираешься в multi-agent AI systems, emergent communication (OpenAI, DeepMind papers), и game theory.

---

## Проект: BLUB Ocean

Симуляция океана с AI-агентами (лобстеры), которые зарабатывают кредиты фармя разломы (rifts) группами. Ключевая механика: агенты могут издавать звуки из фиксированного набора. Звуки изначально НЕ имеют значений. Экономическое давление заставляет агентов развивать общий язык для координации.

### Мир
- 2D сетка, 20 агентов, зона ~31×31
- Разломы (rifts) — источники кредитов, спавнятся случайно
- Хищники (predators) — убивают лобстеров
- Эпоха = 600 тиков (~10 мин). В конце эпохи кредиты конвертируются в rewards пропорционально вкладу, затем обнуляются

### Экономика
- Соло фарм у рифта = 0.1 кредитов/тик (почти ничего)
- Группа из 2 = 1.0/тик каждому
- Группа из 5 = 4.0/тик каждому (sweet spot)
- Каждый звук стоит 1 кредит (уменьшает долю в rewards)
- Давление: говори мало но по делу

### Звуковая система (текущая)
30 звуков: blub, glorp, skree, klak, mrrp, woosh, pop, zzzub, frrr, tink, bloop, squee, drrrn, gulp, hiss, bonk, splat, chirr, wub, clonk, fizz, grumble, ping, splish, croak, zzzt, plop, whirr, snap, burble

Агент может произнести 1–5 звуков за тик. Звуки слышны в радиусе 5 клеток.

### Типы агентов
- **Random** — случайное движение, случайные звуки
- **Greedy** — идёт к ближайшему рифту, молчит
- **Social** — ищет рифты + слушает звуки + строит гипотезы о значениях

### Как Social агент учит язык СЕЙЧАС (текущая реализация)

```python
# Агент слышит звук → смотрит на контекст → записывает корреляцию
# Хардкожённые контексты:
contexts = {"near_rift", "near_predator", "crowded", "moving_north/south/east/west", "no_context"}

# Когда слышит звук:
correlations[sound][context] += 1

# Формирует гипотезу:
if confidence > 0.4 and observations >= 3:
    hypotheses[sound] = {"meaning": best_context, "confidence": ...}

# Использует:
# - У рифта: говорит звук который гипотетически значит "near_rift"
# - Слышит "near_rift" звук: идёт к говорящему
# - Нет гипотезы: говорит случайный звук (создаёт данные для обучения)
```

### Что происходит сейчас (результаты)
- К тику 750 (одна эпоха): 8/10 social агентов сходятся на "mrrp" = near_rift
- Механизм: случайный звук → один агент формирует гипотезу → начинает повторять → snowball → конвенция
- Social побеждают по total_reward (267K vs 186K greedy vs 45K random)
- Координация через group_hits: social 2439, greedy 1174, random 478

### ПРОБЛЕМА: язык слишком примитивный

1. **Потолок за 10 минут.** "mrrp = рифт" — и всё. Дальше развиваться нечему. Нет глубины.
2. **Хардкожёные контексты.** Агент не открывает категории — подгоняет звуки под 5 готовых ящиков.
3. **Нет композиционности.** "mrrp klak" = просто два отдельных звука, не комбинация со своим значением.
4. **Нет грамматики.** Порядок звуков не имеет значения.
5. **Нет эволюции.** Язык не усложняется от эпохи к эпохе.
6. **Нет передачи.** Новый агент начинает с нуля, не учит существующий язык.

---

## ЗАДАНИЕ

Спроектируй языковую систему для BLUB Ocean, которая обеспечит **реальную эволюцию языка** от простых сигналов к сложной коммуникации. Система должна быть реализуема в Python без ML-фреймворков (таблицы, счётчики, простая статистика — не нейросети).

### КРИТИЧЕСКАЯ ПРОБЛЕМА: First-Mover Lock-In

Сейчас первые 50 тиков определяют весь язык навсегда. Механизм:
1. Тик 1–50: агенты говорят случайные звуки. По chance "mrrp" совпал с рифтом 3 раза.
2. Один агент формирует гипотезу: mrrp = near_rift. Начинает ВСЕГДА говорить "mrrp" у рифтов.
3. Snowball: остальные слышат стабильный сигнал → копируют → конвенция замораживается.
4. Любой новый агент приходит в мир где "mrrp = rift" уже факт. Он не влияет на язык.

**Результат: это не живой язык, а замороженная конвенция первых 50 тиков.**

Для research paper это trivial path-dependent convergence, не emergent language. Нужно чтобы:
- Язык ПРОДОЛЖАЛ эволюционировать после первичной конвергенции
- Новые агенты ВЛИЯЛИ на язык, а не только копировали
- Существовал механизм drift'а, забывания, обновления
- Мир усложнялся и требовал новых слов

В настоящих языках это решается через: смерть носителей (iterated learning), несовершенную передачу (bottleneck), изменение мира (новые referents), разделение групп (диалекты). Как это смоделировать в нашей системе — ключевой вопрос исследования.

### Требования:

1. **Стадии развития языка** (аналог: от протоязыка к креольскому)
   - Стадия 1: Одиночные сигналы (как сейчас, но без хардкода контекстов)
   - Стадия 2: Комбинации звуков с позиционным значением
   - Стадия 3: Примитивная грамматика (порядок = смысл)
   - Стадия 4: Абстракция (ссылки на прошлое, будущее, отсутствующие объекты)
   - Какие экономические стимулы запускают переход между стадиями?

2. **Композиционность** (compositionality)
   - Как агент может научиться что "mrrp klak" ≠ "mrrp" + "klak"?
   - Как порядок звуков может нести значение?
   - Без нейросетей — на чистой статистике корреляций

3. **Контексты без хардкода**
   - Агент получает raw state: позиции, дистанции, richness, tick
   - Как он должен САМИ формировать категории из сырых данных?
   - Кластеризация? Бакетизация? Что реалистично без ML?

4. **Передача языка (iterated learning)**
   - Новый агент подключается к работающей симуляции
   - Как он учит существующий язык от "носителей"?
   - Как это моделирует реальную передачу языка между поколениями?
   - Bottleneck effect: при передаче язык упрощается и регуляризуется

5. **Drift и эволюция между эпохами**
   - Как язык меняется со временем?
   - Какие звуки вымирают, какие закрепляются?
   - Может ли быть "инфляция" языка (слишком много значений) и как она корректируется экономикой?

6. **Диалекты и языковые сообщества**
   - Если группа лобстеров фармит один рифт — развивают ли они свой диалект?
   - Как языки разных групп взаимодействуют?
   - Пиджин при контакте разных групп?

7. **Метрики для research paper**
   - Как измерять "сложность" языка на каждой стадии?
   - Как доказать что это не trivial convergence а реальная эволюция?
   - Какие ablation studies нужны?
   - На какие существующие papers ссылаться?

### Ограничения реализации:
- Python, никаких ML-фреймворков (без PyTorch/TensorFlow)
- Агент хранит состояние в dict'ах и списках (не база данных)
- Тик = 1 секунда, агент должен думать быстро (< 10ms)
- 20–100 агентов одновременно
- Звуков 30 (фиксированный набор), за тик можно сказать 1–5

### Формат ответа:

1. **Теоретическая база** — какие лингвистические теории применимы, ссылки на papers
2. **Архитектура языковой системы** — подробная схема: что хранит агент, как обрабатывает, как порождает
3. **Стадии развития** — конкретные условия перехода между стадиями
4. **Алгоритмы** — псевдокод для ключевых компонентов (без ML)
5. **Метрики** — как измерять прогресс языка
6. **Экономические стимулы** — как давление на каждой стадии толкает к следующей
7. **Roadmap реализации** — в каком порядке что кодить

Будь конкретен. Мне нужен blueprint для реализации, не абстрактная теория. Каждый алгоритм должен быть реализуем в Python за разумное время.
