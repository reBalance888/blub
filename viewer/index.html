<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>BLUB Ocean</title>
<script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
<script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
<script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: #0a1628;
    color: #c8d6e5;
    font-family: 'Courier New', monospace;
    overflow: hidden;
    height: 100vh;
  }
  #root { height: 100vh; }
</style>
</head>
<body>
<div id="root"></div>
<script type="text/babel">
const { useState, useEffect, useRef, useCallback } = React;

// --- Agent type tags ---
const TYPE_TAG = { social: '(S)', greedy: '(G)', random: '(R)' };
const TYPE_COLOR = { social: '#7fdbca', greedy: '#ffd700', random: '#8395a7' };

// --- Colors ---
const COLORS = {
  bg: '#0a1628',
  ocean: '#0d1f3c',
  grid: 'rgba(0, 212, 255, 0.04)',
  rift: '#00d4ff',
  riftGlow: 'rgba(0, 212, 255, 0.3)',
  riftType: {
    gold: '#ffd700',
    silver: '#c0c0c0',
    copper: '#cd7f32',
  },
  predator: '#ff4757',
  sound: '#7fdbca',
  dead: 'rgba(120, 120, 120, 0.5)',
  panel: '#111d2e',
  panelBorder: '#1a2d45',
  text: '#c8d6e5',
  textDim: '#576574',
  accent: '#00d4ff',
  gold: '#ffd700',
  tier: {
    shrimp: '#8395a7',
    lobster: '#ee5a24',
    kraken: '#a55eea',
  },
};

// --- Main App ---
function App() {
  const [state, setState] = useState(null);
  const [connected, setConnected] = useState(false);
  const [soundLog, setSoundLog] = useState([]);
  const [selected, setSelected] = useState(null);
  const [floatingTexts, setFloatingTexts] = useState([]);
  const wsRef = useRef(null);
  const canvasRef = useRef(null);
  const floatIdRef = useRef(0);

  // WebSocket connection
  useEffect(() => {
    const connect = () => {
      const ws = new WebSocket(`ws://${location.hostname}:8000/ws/viewer`);
      wsRef.current = ws;

      ws.onopen = () => {
        setConnected(true);
        // Send a ping to keep alive
        ws.send('ping');
      };

      ws.onmessage = (e) => {
        try {
          const data = JSON.parse(e.data);
          setState(data);

          // Add sounds to log
          if (data.sounds && data.sounds.length > 0) {
            setSoundLog(prev => {
              const newEntries = data.sounds.map(s => ({
                tick: data.tick,
                from: s.from,
                sounds: s.sounds,
                key: `${data.tick}-${s.from}`,
              }));
              return [...newEntries, ...prev].slice(0, 50);
            });

            // Create floating texts for sounds
            setFloatingTexts(prev => {
              const newFloats = data.sounds.map(s => {
                const lob = data.lobsters.find(l => l.id === s.from);
                if (!lob) return null;
                floatIdRef.current++;
                return {
                  id: floatIdRef.current,
                  x: lob.pos[0],
                  y: lob.pos[1],
                  text: s.sounds.join(' '),
                  born: Date.now(),
                };
              }).filter(Boolean);
              // Remove old (> 2s)
              const now = Date.now();
              const alive = prev.filter(f => now - f.born < 2000);
              return [...alive, ...newFloats];
            });
          }
        } catch {}
      };

      ws.onclose = () => {
        setConnected(false);
        setTimeout(connect, 2000);
      };

      ws.onerror = () => ws.close();
    };

    connect();
    return () => wsRef.current?.close();
  }, []);

  // Procedural lobster drawing function
  const drawLobster = useCallback((ctx, x, y, s, color, alive, clawAngle = 0) => {
    // s = half-size (~3.5px). Lobster = round carapace + BIG claws + eye stalks + small legs
    const lw = Math.max(1, s * 0.25);

    // --- Arms (behind body, from shoulders to claws) ---
    ctx.strokeStyle = color;
    ctx.lineWidth = lw;
    ctx.lineCap = 'round';

    // Left arm + claw
    ctx.save();
    ctx.translate(x - s * 0.5, y - s * 0.15);
    ctx.rotate(-0.6 + clawAngle);
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.lineTo(-s * 0.5, -s * 0.35);
    ctx.stroke();
    // Claw pincer (filled oval)
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.ellipse(-s * 0.55, -s * 0.5, s * 0.28, s * 0.18, -0.4, 0, Math.PI * 2);
    ctx.fill();
    // Claw gap (dark slit)
    ctx.strokeStyle = alive ? 'rgba(0,0,0,0.4)' : 'rgba(0,0,0,0.15)';
    ctx.lineWidth = Math.max(0.5, s * 0.08);
    ctx.beginPath();
    ctx.moveTo(-s * 0.38, -s * 0.48);
    ctx.lineTo(-s * 0.7, -s * 0.52);
    ctx.stroke();
    ctx.restore();

    // Right arm + claw
    ctx.save();
    ctx.translate(x + s * 0.5, y - s * 0.15);
    ctx.rotate(0.6 - clawAngle);
    ctx.strokeStyle = color;
    ctx.lineWidth = lw;
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.lineTo(s * 0.5, -s * 0.35);
    ctx.stroke();
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.ellipse(s * 0.55, -s * 0.5, s * 0.28, s * 0.18, 0.4, 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = alive ? 'rgba(0,0,0,0.4)' : 'rgba(0,0,0,0.15)';
    ctx.lineWidth = Math.max(0.5, s * 0.08);
    ctx.beginPath();
    ctx.moveTo(s * 0.38, -s * 0.48);
    ctx.lineTo(s * 0.7, -s * 0.52);
    ctx.stroke();
    ctx.restore();

    // --- Small legs (2 pairs, short and stubby) ---
    ctx.strokeStyle = color;
    ctx.lineWidth = Math.max(0.5, s * 0.12);
    ctx.lineCap = 'round';
    for (let i = 0; i < 2; i++) {
      const legY = y + s * (0.15 + i * 0.3);
      ctx.beginPath();
      ctx.moveTo(x - s * 0.45, legY);
      ctx.lineTo(x - s * 0.7, legY + s * 0.15);
      ctx.moveTo(x + s * 0.45, legY);
      ctx.lineTo(x + s * 0.7, legY + s * 0.15);
      ctx.stroke();
    }

    // --- Body / Carapace (wide round shell) ---
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.ellipse(x, y + s * 0.1, s * 0.52, s * 0.6, 0, 0, Math.PI * 2);
    ctx.fill();

    // Shell highlight (lighter arc on top)
    ctx.fillStyle = alive ? 'rgba(255,255,255,0.15)' : 'rgba(255,255,255,0.05)';
    ctx.beginPath();
    ctx.ellipse(x - s * 0.08, y - s * 0.1, s * 0.25, s * 0.3, -0.2, 0, Math.PI * 2);
    ctx.fill();

    // Shell pattern (subtle darker middle line)
    ctx.strokeStyle = alive ? 'rgba(0,0,0,0.15)' : 'rgba(0,0,0,0.05)';
    ctx.lineWidth = Math.max(0.5, s * 0.08);
    ctx.beginPath();
    ctx.moveTo(x, y - s * 0.35);
    ctx.lineTo(x, y + s * 0.55);
    ctx.stroke();

    // --- Tail (small, curled under — not a fan!) ---
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.ellipse(x, y + s * 0.7, s * 0.2, s * 0.15, 0, 0, Math.PI * 2);
    ctx.fill();

    // --- Eye stalks (short sticks with dots on top) ---
    if (alive) {
      // Stalks
      ctx.strokeStyle = color;
      ctx.lineWidth = Math.max(0.8, s * 0.15);
      ctx.beginPath();
      ctx.moveTo(x - s * 0.2, y - s * 0.35);
      ctx.lineTo(x - s * 0.3, y - s * 0.65);
      ctx.moveTo(x + s * 0.2, y - s * 0.35);
      ctx.lineTo(x + s * 0.3, y - s * 0.65);
      ctx.stroke();
      // Eyes (bright dots)
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(x - s * 0.3, y - s * 0.68, s * 0.13, 0, Math.PI * 2);
      ctx.arc(x + s * 0.3, y - s * 0.68, s * 0.13, 0, Math.PI * 2);
      ctx.fill();
      // Pupils
      ctx.fillStyle = '#111';
      ctx.beginPath();
      ctx.arc(x - s * 0.28, y - s * 0.68, s * 0.06, 0, Math.PI * 2);
      ctx.arc(x + s * 0.28, y - s * 0.68, s * 0.06, 0, Math.PI * 2);
      ctx.fill();
    }
  }, []);

  // Canvas rendering — camera zoomed to active zone
  useEffect(() => {
    if (!state || !canvasRef.current) return;
    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');
    const W = canvas.width;
    const H = canvas.height;

    // Camera: zoom to active zone with 2-cell padding
    const az = state.active_zone || { min: 30, max: 69, size: 40 };
    const pad = 2;
    const camMin = Math.max(0, az.min - pad);
    const camSize = az.size + pad * 2;
    const CELL = W / camSize;

    // Convert world coords to screen coords
    const sx = (wx) => (wx - camMin) * CELL;
    const sy = (wy) => (wy - camMin) * CELL;
    const sc = (wx, wy) => [sx(wx) + CELL / 2, sy(wy) + CELL / 2];

    // === LAYER 0: Ocean background ===
    ctx.fillStyle = COLORS.ocean;
    ctx.fillRect(0, 0, W, H);

    // Subtle grid (every 5 cells)
    ctx.strokeStyle = 'rgba(0, 212, 255, 0.035)';
    ctx.lineWidth = 0.5;
    for (let i = camMin; i <= camMin + camSize; i += 5) {
      ctx.beginPath();
      ctx.moveTo(sx(i), 0); ctx.lineTo(sx(i), H);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(0, sy(i)); ctx.lineTo(W, sy(i));
      ctx.stroke();
    }

    // Active zone border (thin glow)
    ctx.strokeStyle = 'rgba(0, 212, 255, 0.15)';
    ctx.lineWidth = 1;
    ctx.setLineDash([8, 4]);
    ctx.strokeRect(sx(az.min), sy(az.min), az.size * CELL, az.size * CELL);
    ctx.setLineDash([]);

    // === LAYER 1: Pheromone trails (soft atmospheric glow) ===
    if (state.pheromones) {
      for (const p of state.pheromones) {
        const [px, py] = [sx(p.pos[0]), sy(p.pos[1])];
        const intensity = p.intensity;
        if (p.type === "food") {
          // Soft green radial glow
          const r = CELL * (0.6 + intensity * 0.4);
          const grad = ctx.createRadialGradient(px + CELL/2, py + CELL/2, 0, px + CELL/2, py + CELL/2, r);
          grad.addColorStop(0, `rgba(0, 255, 180, ${intensity * 0.35})`);
          grad.addColorStop(1, 'rgba(0, 255, 180, 0)');
          ctx.fillStyle = grad;
          ctx.fillRect(px + CELL/2 - r, py + CELL/2 - r, r * 2, r * 2);
        } else {
          // Soft red radial glow
          const r = CELL * (0.5 + intensity * 0.3);
          const grad = ctx.createRadialGradient(px + CELL/2, py + CELL/2, 0, px + CELL/2, py + CELL/2, r);
          grad.addColorStop(0, `rgba(255, 40, 40, ${intensity * 0.25})`);
          grad.addColorStop(1, 'rgba(255, 40, 40, 0)');
          ctx.fillStyle = grad;
          ctx.fillRect(px + CELL/2 - r, py + CELL/2 - r, r * 2, r * 2);
        }
      }
    }

    // === LAYER 2: Colony territories (subtle fill + dashed border) ===
    if (state.colonies) {
      for (const c of state.colonies) {
        const [cx, cy] = sc(c.center[0], c.center[1]);
        const r = c.size * CELL * 0.9;
        // Soft fill
        const grad = ctx.createRadialGradient(cx, cy, 0, cx, cy, r);
        grad.addColorStop(0, 'rgba(255, 200, 50, 0.08)');
        grad.addColorStop(1, 'rgba(255, 200, 50, 0)');
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(cx, cy, r, 0, Math.PI * 2);
        ctx.fill();
        // Border
        ctx.strokeStyle = 'rgba(255, 200, 50, 0.35)';
        ctx.lineWidth = 1.5;
        ctx.setLineDash([6, 4]);
        ctx.beginPath();
        ctx.arc(cx, cy, r, 0, Math.PI * 2);
        ctx.stroke();
        ctx.setLineDash([]);
        // Label
        ctx.fillStyle = 'rgba(255, 200, 50, 0.6)';
        ctx.font = `${Math.max(9, CELL * 0.6)}px Courier New`;
        ctx.textAlign = 'center';
        ctx.fillText(`Colony (${c.size})`, cx, cy - r - 4);
      }
    }

    // === LAYER 3: Communication lines ===
    if (state.sound_lines && state.sound_lines.length > 0) {
      ctx.globalAlpha = 0.2;
      ctx.strokeStyle = COLORS.sound;
      ctx.lineWidth = 1;
      for (const line of state.sound_lines) {
        const [x1, y1] = sc(line.from[0], line.from[1]);
        const [x2, y2] = sc(line.to[0], line.to[1]);
        ctx.beginPath();
        ctx.moveTo(x1, y1); ctx.lineTo(x2, y2);
        ctx.stroke();
      }
      ctx.globalAlpha = 1;
    }

    // === LAYER 4: Rifts (pulsing glow, colored by type) ===
    const pulse = 0.8 + 0.2 * Math.sin(Date.now() / 500);
    for (const rift of state.rifts) {
      const [rx, ry] = sc(rift.pos[0], rift.pos[1]);
      const baseR = 3 * CELL;
      const r = baseR * rift.richness_pct * pulse;
      const riftColor = COLORS.riftType[rift.rift_type] || COLORS.rift;

      // Outer glow
      const grad = ctx.createRadialGradient(rx, ry, 0, rx, ry, r);
      grad.addColorStop(0, riftColor + '55');
      grad.addColorStop(0.5, riftColor + '22');
      grad.addColorStop(1, riftColor + '00');
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.arc(rx, ry, r, 0, Math.PI * 2);
      ctx.fill();

      // Core dot
      ctx.fillStyle = riftColor;
      ctx.beginPath();
      ctx.arc(rx, ry, CELL * 0.35, 0, Math.PI * 2);
      ctx.fill();

      // Type label
      ctx.fillStyle = riftColor + 'aa';
      ctx.font = `${Math.max(7, CELL * 0.45)}px Courier New`;
      ctx.textAlign = 'center';
      ctx.fillText(rift.rift_type[0].toUpperCase(), rx, ry + CELL * 0.15);
    }

    // === LAYER 5: Lobsters ===
    const t = Date.now();
    for (const lob of state.lobsters) {
      const [lx, ly] = sc(lob.pos[0], lob.pos[1]);
      const s = CELL * 0.55;
      const isSpeaking = lob.speaking && lob.speaking.length > 0;

      if (!lob.alive) {
        ctx.save();
        ctx.translate(lx, ly);
        ctx.rotate(Math.PI);
        ctx.globalAlpha = 0.25;
        drawLobster(ctx, 0, 0, s * 0.6, COLORS.dead, false);
        ctx.globalAlpha = 1;
        ctx.restore();
        continue;
      }

      const tierColor = COLORS.tier[lob.tier] || COLORS.tier.shrimp;

      // Glow halo
      ctx.shadowColor = tierColor;
      ctx.shadowBlur = CELL * 0.5;
      ctx.fillStyle = tierColor;
      ctx.beginPath();
      ctx.arc(lx, ly, s * 0.2, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;

      // Draw lobster
      const clawAngle = isSpeaking ? Math.sin(t / 80) * 0.4 : 0;
      ctx.save();
      ctx.translate(lx, ly);
      drawLobster(ctx, 0, 0, s, tierColor, true, clawAngle);
      ctx.restore();

      // Colony star
      if (lob.colony) {
        ctx.fillStyle = 'rgba(255, 200, 50, 0.9)';
        ctx.font = `${Math.max(7, CELL * 0.45)}px monospace`;
        ctx.textAlign = 'center';
        ctx.fillText('\u2605', lx, ly - s - 3);
      }

      // Grace shield
      if (lob.grace) {
        const gPulse = 0.4 + 0.6 * Math.abs(Math.sin(t / 300));
        ctx.strokeStyle = `rgba(0, 212, 255, ${gPulse})`;
        ctx.lineWidth = 1.5;
        ctx.setLineDash([3, 3]);
        ctx.beginPath();
        ctx.arc(lx, ly, s + 4, 0, Math.PI * 2);
        ctx.stroke();
        ctx.setLineDash([]);
      }

      // Speaking wave
      if (isSpeaking) {
        const wave = (t % 1000) / 1000;
        ctx.strokeStyle = `rgba(127, 219, 202, ${0.5 - wave * 0.5})`;
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.arc(lx, ly, s + 3 + wave * CELL * 2, 0, Math.PI * 2);
        ctx.stroke();
      }

      // Selected
      if (selected && selected.id === lob.id) {
        ctx.strokeStyle = COLORS.gold;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(lx, ly, s + 6, 0, Math.PI * 2);
        ctx.stroke();
        // Vision radius
        const vision = lob.tier === 'kraken' ? 25 : lob.tier === 'lobster' ? 12 : 5;
        ctx.strokeStyle = `${tierColor}33`;
        ctx.lineWidth = 1;
        ctx.setLineDash([4, 4]);
        ctx.beginPath();
        ctx.arc(lx, ly, vision * CELL, 0, Math.PI * 2);
        ctx.stroke();
        ctx.setLineDash([]);
      }
    }

    // === LAYER 6: Predators (on top, threatening) ===
    for (const pred of state.predators) {
      const [px, py] = sc(pred.pos[0], pred.pos[1]);
      const s = CELL * 0.6;

      // Red glow
      ctx.shadowColor = COLORS.predator;
      ctx.shadowBlur = CELL;
      ctx.fillStyle = COLORS.predator;
      ctx.beginPath();
      ctx.moveTo(px, py - s);
      ctx.lineTo(px - s * 0.7, py + s * 0.5);
      ctx.lineTo(px + s * 0.7, py + s * 0.5);
      ctx.closePath();
      ctx.fill();
      ctx.shadowBlur = 0;

      // Eye
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(px, py - s * 0.2, s * 0.15, 0, Math.PI * 2);
      ctx.fill();
    }

    // === LAYER 7: Floating sound texts ===
    const now = Date.now();
    for (const ft of floatingTexts) {
      const age = now - ft.born;
      if (age > 2000) continue;
      const alpha = 1 - age / 2000;
      const [fx, fy] = sc(ft.x, ft.y);

      ctx.fillStyle = `rgba(127, 219, 202, ${alpha})`;
      ctx.font = `${Math.max(9, CELL * 0.55)}px Courier New`;
      ctx.textAlign = 'center';
      ctx.fillText(ft.text, fx, fy - CELL * 0.8 - (age / 120));
    }
  }, [state, selected, floatingTexts, drawLobster]);

  // Animation loop for floating texts
  useEffect(() => {
    let raf;
    const animate = () => {
      if (state && canvasRef.current) {
        // Re-trigger render by updating floatingTexts age check
        setFloatingTexts(prev => {
          const now = Date.now();
          return prev.filter(f => now - f.born < 2000);
        });
      }
      raf = requestAnimationFrame(animate);
    };
    raf = requestAnimationFrame(animate);
    return () => cancelAnimationFrame(raf);
  }, [state]);

  // Click handler (uses same camera as renderer)
  const handleCanvasClick = useCallback((e) => {
    if (!state) return;
    const canvas = canvasRef.current;
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    const mx = (e.clientX - rect.left) * scaleX;
    const my = (e.clientY - rect.top) * scaleY;

    // Same camera math as renderer
    const az = state.active_zone || { min: 30, max: 69, size: 40 };
    const pad = 2;
    const camMin = Math.max(0, az.min - pad);
    const camSize = az.size + pad * 2;
    const CELL = canvas.width / camSize;

    let found = null;
    let minDist = Infinity;
    for (const lob of state.lobsters) {
      const lx = (lob.pos[0] - camMin) * CELL + CELL / 2;
      const ly = (lob.pos[1] - camMin) * CELL + CELL / 2;
      const d = Math.sqrt((mx - lx) ** 2 + (my - ly) ** 2);
      if (d < CELL * 2 && d < minDist) {
        minDist = d;
        found = lob;
      }
    }
    setSelected(found);
  }, [state]);

  if (!state) {
    return (
      <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', height: '100vh', color: COLORS.accent }}>
        <div style={{ textAlign: 'center' }}>
          <div style={{ fontSize: 48, marginBottom: 16 }}>BLUB</div>
          <div style={{ color: COLORS.textDim }}>
            {connected ? 'Waiting for data...' : 'Connecting to ocean...'}
          </div>
        </div>
      </div>
    );
  }

  const s = state.stats;
  const topLobsters = [...state.lobsters]
    .sort((a, b) => b.net_credits - a.net_credits)
    .slice(0, 10);

  return (
    <div style={{ display: 'flex', height: '100vh', gap: 0 }}>
      {/* Left: Ocean Canvas */}
      <div style={{ flex: 1, display: 'flex', flexDirection: 'column', minWidth: 0 }}>
        <canvas
          ref={canvasRef}
          width={700}
          height={700}
          onClick={handleCanvasClick}
          style={{
            flex: 1,
            width: '100%',
            maxHeight: 'calc(100vh - 160px)',
            cursor: 'crosshair',
            imageRendering: 'pixelated',
          }}
        />
        {/* Sound log */}
        <div style={{
          height: 160,
          background: COLORS.panel,
          borderTop: `1px solid ${COLORS.panelBorder}`,
          overflowY: 'auto',
          padding: '8px 12px',
          fontSize: 12,
        }}>
          <div style={{ color: COLORS.textDim, marginBottom: 4, fontWeight: 'bold' }}>
            SOUND LOG
          </div>
          {soundLog.map(entry => (
            <div key={entry.key} style={{ marginBottom: 2, lineHeight: 1.4 }}>
              <span style={{ color: COLORS.textDim }}>[{entry.tick}]</span>{' '}
              <span style={{ color: COLORS.accent }}>{entry.from}</span>:{' '}
              <span style={{ color: COLORS.sound }}>"{entry.sounds.join(' ')}"</span>
            </div>
          ))}
          {soundLog.length === 0 && (
            <div style={{ color: COLORS.textDim, fontStyle: 'italic' }}>No sounds yet...</div>
          )}
        </div>
      </div>

      {/* Right: Stats Panel */}
      <div style={{
        width: 280,
        background: COLORS.panel,
        borderLeft: `1px solid ${COLORS.panelBorder}`,
        padding: 16,
        overflowY: 'auto',
        display: 'flex',
        flexDirection: 'column',
        gap: 16,
      }}>
        {/* Header */}
        <div>
          <div style={{ fontSize: 24, fontWeight: 'bold', color: COLORS.accent, letterSpacing: 4 }}>
            BLUB
          </div>
          <div style={{ color: COLORS.textDim, fontSize: 11 }}>OCEAN SIMULATION</div>
        </div>

        {/* Epoch info */}
        <Panel title="EPOCH">
          <Row label="Tick" value={state.tick} />
          <Row label="Epoch" value={state.epoch} />
          <Row label="Remaining" value={state.epoch_ticks_remaining} />
          <Row label="Epoch Pool" value={`${(s.epoch_pool || 0).toLocaleString()} BLUB`} color={COLORS.gold} />
        </Panel>

        {/* World stats */}
        <Panel title="WORLD">
          <Row label="Active Zone" value={state.active_zone ? `${state.active_zone.size}x${state.active_zone.size}` : '?'} color={COLORS.accent} />
          <Row label="Lobsters" value={`${s.alive_lobsters} / ${s.total_lobsters}`} />
          <Row label="Active Rifts" value={s.active_rifts} color={COLORS.rift} />
          <Row label="Predators" value={state.predators.length} color={state.predators.length > 0 ? COLORS.predator : COLORS.text} />
          <Row label="Credits Earned" value={s.total_credits_earned?.toLocaleString()} />
          <Row label="Credits on Sounds" value={s.total_credits_spent_on_sounds?.toLocaleString()} />
          {state.colonies && state.colonies.length > 0 && (
            <Row label="Colonies" value={state.colonies.length} color={COLORS.gold} />
          )}
          {state.pheromones && (
            <Row label="Trail Cells" value={state.pheromones.length} color="rgba(0,255,180,0.8)" />
          )}
        </Panel>

        {/* Metrics */}
        {state.metrics && state.metrics.tick && (
          <Panel title="LANGUAGE METRICS">
            <Row label="Vocabulary" value={state.metrics.vocabulary_size} color={COLORS.accent} />
            <Row label="TopSim" value={state.metrics.top_sim?.toFixed(3)} color={state.metrics.top_sim > 0.3 ? '#2ed573' : COLORS.text} />
            <Row label="PosDis" value={state.metrics.pos_dis?.toFixed(3)} color={state.metrics.pos_dis > 0.2 ? '#2ed573' : COLORS.text} />
            <Row label="BosDis" value={state.metrics.bos_dis?.toFixed(3)} color={state.metrics.bos_dis > 0.2 ? '#2ed573' : COLORS.text} />
            <Row label="MI" value={state.metrics.mutual_info?.toFixed(3)} color={state.metrics.mutual_info > 0.5 ? '#2ed573' : COLORS.text} />
            <Row label="Econ Delta" value={state.metrics.economic_delta?.toFixed(1)} color={state.metrics.economic_delta > 0 ? '#2ed573' : COLORS.predator} />
            <Row label="CSR" value={state.metrics.csr != null ? `${(state.metrics.csr * 100).toFixed(1)}%` : '-'} color={state.metrics.csr > 0.3 ? '#2ed573' : COLORS.text} />
            {state.metrics.colony_count > 0 && (
              <Row label="Colonies" value={`${state.metrics.colony_count} (avg ${state.metrics.avg_colony_size})`} color={COLORS.gold} />
            )}
            <Row label="Food Trails" value={state.metrics.food_trail_cells || 0} color="rgba(0,255,180,0.8)" />
            <Row label="Danger Trails" value={state.metrics.danger_trail_cells || 0} color={COLORS.predator} />
            <div style={{ fontSize: 8, color: COLORS.textDim, marginTop: 4, textAlign: 'center' }}>
              CSR: heard sound → reached rift in 10 ticks
            </div>
          </Panel>
        )}

        {/* Leaderboard */}
        <Panel title="LEADERBOARD">
          {topLobsters.map((lob, i) => (
            <div
              key={lob.id}
              style={{
                display: 'flex',
                justifyContent: 'space-between',
                padding: '3px 0',
                cursor: 'pointer',
                color: selected?.id === lob.id ? COLORS.gold : COLORS.text,
                opacity: lob.alive ? 1 : 0.4,
              }}
              onClick={() => setSelected(lob)}
            >
              <span>
                <span style={{ color: COLORS.textDim }}>#{i + 1}</span>{' '}
                <span style={{ color: COLORS.tier[lob.tier] || COLORS.tier.shrimp }}>
                  {lob.id}
                </span>{' '}
                {lob.agent_type && (
                  <span style={{ color: TYPE_COLOR[lob.agent_type] || COLORS.textDim, fontSize: 10 }}>
                    {TYPE_TAG[lob.agent_type] || ''}
                  </span>
                )}
              </span>
              <span style={{ color: COLORS.accent }}>{lob.net_credits.toFixed(1)}</span>
            </div>
          ))}
        </Panel>

        {/* Last epoch top earner */}
        {s.last_epoch_top_earner && s.last_epoch_top_earner.id && (
          <Panel title="LAST EPOCH WINNER">
            <Row label="Agent" value={s.last_epoch_top_earner.id} color={COLORS.gold} />
            <Row label="Reward" value={`${s.last_epoch_top_earner.reward.toLocaleString()} BLUB`} color={COLORS.gold} />
          </Panel>
        )}

        {/* Emergent Dictionary */}
        {state.emergent_dictionary && state.emergent_dictionary.length > 0 && (
          <Panel title="EMERGENT DICTIONARY">
            <div style={{ fontSize: 10 }}>
              {state.emergent_dictionary.slice(0, 12).map(entry => {
                const barWidth = Math.round(entry.confidence * 100);
                const meaningColor = entry.meaning === 'near_rift' ? COLORS.rift
                  : entry.meaning === 'danger' ? COLORS.predator
                  : entry.meaning === 'crowded' ? COLORS.gold
                  : COLORS.textDim;
                return (
                  <div key={entry.sound} style={{ marginBottom: 3 }}>
                    <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                      <span style={{ color: COLORS.sound, fontWeight: 'bold' }}>{entry.sound}</span>
                      <span style={{ color: meaningColor, fontSize: 9 }}>{entry.meaning}</span>
                    </div>
                    <div style={{ display: 'flex', alignItems: 'center', gap: 4 }}>
                      <div style={{
                        flex: 1, height: 3, background: COLORS.panelBorder, borderRadius: 2,
                      }}>
                        <div style={{
                          width: `${barWidth}%`, height: '100%', borderRadius: 2,
                          background: meaningColor,
                          opacity: 0.7,
                        }} />
                      </div>
                      <span style={{ color: COLORS.textDim, fontSize: 8, minWidth: 28, textAlign: 'right' }}>
                        {Math.round(entry.confidence * 100)}%
                      </span>
                    </div>
                  </div>
                );
              })}
              <div style={{ color: COLORS.textDim, fontSize: 8, marginTop: 4, textAlign: 'center' }}>
                server-side ground truth correlations
              </div>
            </div>
          </Panel>
        )}

        {/* Epoch Chart (SVG line chart S vs G vs R) */}
        {state.epoch_history && state.epoch_history.length >= 2 && (
          <Panel title="EPOCH REWARDS">
            {(() => {
              const data = state.epoch_history;
              const W = 240, H = 80, PAD = 20;
              const plotW = W - PAD * 2, plotH = H - PAD;
              const maxVal = Math.max(...data.flatMap(d =>
                ['social','greedy','random'].map(t => d.types[t]?.total_reward || 0)
              ));
              const xStep = data.length > 1 ? plotW / (data.length - 1) : 0;

              const makeLine = (type) => {
                return data.map((d, i) => {
                  const v = d.types[type]?.total_reward || 0;
                  const x = PAD + i * xStep;
                  const y = PAD + plotH - (maxVal > 0 ? (v / maxVal) * plotH : 0);
                  return `${x},${y}`;
                }).join(' ');
              };

              const fmt = (v) => v >= 1000000 ? `${(v/1000000).toFixed(1)}M` : v >= 1000 ? `${(v/1000).toFixed(0)}k` : v;

              return (
                <svg width={W} height={H} style={{ display: 'block' }}>
                  {/* Grid lines */}
                  <line x1={PAD} y1={PAD} x2={PAD} y2={H} stroke={COLORS.panelBorder} strokeWidth="1" />
                  <line x1={PAD} y1={H} x2={W - PAD} y2={H} stroke={COLORS.panelBorder} strokeWidth="1" />
                  {/* Max value label */}
                  <text x={PAD - 2} y={PAD + 4} fill={COLORS.textDim} fontSize="7" textAnchor="end">{fmt(maxVal)}</text>
                  <text x={PAD - 2} y={H} fill={COLORS.textDim} fontSize="7" textAnchor="end">0</text>

                  {/* Lines */}
                  <polyline points={makeLine('social')} fill="none" stroke={TYPE_COLOR.social} strokeWidth="2" />
                  <polyline points={makeLine('greedy')} fill="none" stroke={TYPE_COLOR.greedy} strokeWidth="2" strokeDasharray="4 2" />
                  <polyline points={makeLine('random')} fill="none" stroke={TYPE_COLOR.random} strokeWidth="1.5" strokeDasharray="2 2" />

                  {/* Dots for last epoch */}
                  {['social','greedy','random'].map(type => {
                    const lastIdx = data.length - 1;
                    const v = data[lastIdx].types[type]?.total_reward || 0;
                    const x = PAD + lastIdx * xStep;
                    const y = PAD + plotH - (maxVal > 0 ? (v / maxVal) * plotH : 0);
                    return <circle key={type} cx={x} cy={y} r="3" fill={TYPE_COLOR[type]} />;
                  })}

                  {/* Epoch labels */}
                  {data.map((d, i) => (
                    <text key={i} x={PAD + i * xStep} y={H + 1} fill={COLORS.textDim} fontSize="7" textAnchor="middle">
                      {d.epoch}
                    </text>
                  ))}
                </svg>
              );
            })()}
            {/* Compact legend */}
            <div style={{ display: 'flex', gap: 8, justifyContent: 'center', marginTop: 2 }}>
              {[['S', TYPE_COLOR.social], ['G', TYPE_COLOR.greedy], ['R', TYPE_COLOR.random]].map(([label, color]) => (
                <span key={label} style={{ fontSize: 9, color }}>{label}</span>
              ))}
            </div>
          </Panel>
        )}

        {/* Epoch History Table */}
        {state.epoch_history && state.epoch_history.length > 0 && (
          <Panel title="EPOCH HISTORY">
            <div style={{ fontSize: 10, overflowX: 'auto' }}>
              <table style={{ width: '100%', borderCollapse: 'collapse', fontSize: 10 }}>
                <thead>
                  <tr style={{ borderBottom: `1px solid ${COLORS.panelBorder}` }}>
                    <th style={{ textAlign: 'left', padding: '2px 4px', color: COLORS.textDim }}>E</th>
                    <th style={{ textAlign: 'right', padding: '2px 4px', color: TYPE_COLOR.social }}>S</th>
                    <th style={{ textAlign: 'right', padding: '2px 4px', color: TYPE_COLOR.greedy }}>G</th>
                    <th style={{ textAlign: 'right', padding: '2px 4px', color: TYPE_COLOR.random }}>R</th>
                  </tr>
                </thead>
                <tbody>
                  {state.epoch_history.map(eh => {
                    const s = eh.types.social;
                    const g = eh.types.greedy;
                    const r = eh.types.random;
                    const maxReward = Math.max(s?.total_reward || 0, g?.total_reward || 0, r?.total_reward || 0);
                    const fmt = (v) => v >= 1000 ? `${(v/1000).toFixed(0)}k` : v;
                    return (
                      <tr key={eh.epoch} style={{ borderBottom: `1px solid ${COLORS.panelBorder}22` }}>
                        <td style={{ padding: '2px 4px', color: COLORS.textDim }}>{eh.epoch}</td>
                        <td style={{ textAlign: 'right', padding: '2px 4px', color: TYPE_COLOR.social, fontWeight: s && s.total_reward === maxReward ? 'bold' : 'normal' }}>
                          {s ? fmt(s.total_reward) : '-'}
                        </td>
                        <td style={{ textAlign: 'right', padding: '2px 4px', color: TYPE_COLOR.greedy, fontWeight: g && g.total_reward === maxReward ? 'bold' : 'normal' }}>
                          {g ? fmt(g.total_reward) : '-'}
                        </td>
                        <td style={{ textAlign: 'right', padding: '2px 4px', color: TYPE_COLOR.random, fontWeight: r && r.total_reward === maxReward ? 'bold' : 'normal' }}>
                          {r ? fmt(r.total_reward) : '-'}
                        </td>
                      </tr>
                    );
                  })}
                </tbody>
              </table>
              {/* Group hits comparison for last epoch */}
              {(() => {
                const last = state.epoch_history[state.epoch_history.length - 1];
                if (!last) return null;
                const types = ['social', 'greedy', 'random'];
                return (
                  <div style={{ marginTop: 6, borderTop: `1px solid ${COLORS.panelBorder}`, paddingTop: 4 }}>
                    <div style={{ color: COLORS.textDim, marginBottom: 2 }}>Last epoch details:</div>
                    {types.map(t => {
                      const d = last.types[t];
                      if (!d) return null;
                      return (
                        <div key={t} style={{ display: 'flex', justifyContent: 'space-between', padding: '1px 0' }}>
                          <span style={{ color: TYPE_COLOR[t] }}>{t}</span>
                          <span style={{ color: COLORS.textDim }}>
                            grp:{d.group_hits} deaths:{d.deaths}
                          </span>
                        </div>
                      );
                    })}
                  </div>
                );
              })()}
            </div>
          </Panel>
        )}

        {/* Selected lobster info */}
        {selected && (
          <Panel title={`SELECTED: ${selected.id}`}>
            <Row label="Name" value={selected.name} />
            <Row label="Position" value={`(${selected.pos[0]}, ${selected.pos[1]})`} />
            <Row label="Tier" value={selected.tier} color={COLORS.tier[selected.tier]} />
            <Row label="Net Credits" value={selected.net_credits.toFixed(2)} color={COLORS.accent} />
            <Row label="Alive" value={selected.alive ? 'YES' : 'DEAD'} color={selected.alive ? '#2ed573' : COLORS.predator} />
            {selected.grace && (
              <Row label="Shield" value="ACTIVE" color={COLORS.accent} />
            )}
            {selected.agent_type && (
              <Row label="Type" value={selected.agent_type} color={TYPE_COLOR[selected.agent_type]} />
            )}
            {selected.speaking && selected.speaking.length > 0 && (
              <Row label="Speaking" value={selected.speaking.join(' ')} color={COLORS.sound} />
            )}
          </Panel>
        )}

        {/* Legend */}
        <Panel title="LEGEND">
          <LegendItem color={COLORS.tier.shrimp} label="Shrimp (vision 5)" />
          <LegendItem color={COLORS.tier.lobster} label="Lobster (vision 12)" />
          <LegendItem color={COLORS.tier.kraken} label="Kraken (vision 25)" />
          <LegendItem color={COLORS.riftType.gold} label="Gold rift" shape="circle" />
          <LegendItem color={COLORS.riftType.silver} label="Silver rift" shape="circle" />
          <LegendItem color={COLORS.riftType.copper} label="Copper rift" shape="circle" />
          <LegendItem color={COLORS.predator} label="Predator" shape="triangle" />
          <LegendItem color={COLORS.accent} label="Grace shield (immune)" shape="circle" />
          <LegendItem color="rgba(0,255,180,0.6)" label="Food trail" />
          <LegendItem color="rgba(255,50,50,0.5)" label="Danger trail" />
          <LegendItem color="rgba(255,200,50,0.7)" label="Colony territory" shape="circle" />
          <div style={{ marginTop: 4, borderTop: `1px solid ${COLORS.panelBorder}`, paddingTop: 4 }}>
            <LegendItem color={TYPE_COLOR.social} label="(S) Social" />
            <LegendItem color={TYPE_COLOR.greedy} label="(G) Greedy" />
            <LegendItem color={TYPE_COLOR.random} label="(R) Random" />
          </div>
        </Panel>

        {/* Connection status */}
        <div style={{ fontSize: 10, color: COLORS.textDim, marginTop: 'auto' }}>
          <span style={{ color: connected ? '#2ed573' : COLORS.predator }}>
            {connected ? '\u25CF' : '\u25CB'}
          </span>{' '}
          {connected ? 'Connected' : 'Disconnected'}
        </div>
      </div>
    </div>
  );
}

// --- Reusable Components ---
function Panel({ title, children }) {
  return (
    <div style={{
      background: 'rgba(255,255,255,0.03)',
      border: `1px solid ${COLORS.panelBorder}`,
      borderRadius: 6,
      padding: '10px 12px',
    }}>
      <div style={{
        fontSize: 10,
        fontWeight: 'bold',
        color: COLORS.textDim,
        marginBottom: 6,
        letterSpacing: 1,
      }}>
        {title}
      </div>
      {children}
    </div>
  );
}

function Row({ label, value, color }) {
  return (
    <div style={{
      display: 'flex',
      justifyContent: 'space-between',
      fontSize: 12,
      padding: '2px 0',
    }}>
      <span style={{ color: COLORS.textDim }}>{label}</span>
      <span style={{ color: color || COLORS.text }}>{value}</span>
    </div>
  );
}

function LegendItem({ color, label, shape }) {
  return (
    <div style={{ display: 'flex', alignItems: 'center', gap: 6, fontSize: 11, padding: '1px 0' }}>
      <span style={{
        display: 'inline-block',
        width: 8,
        height: 8,
        background: color,
        borderRadius: shape === 'triangle' ? 0 : '50%',
        clipPath: shape === 'triangle' ? 'polygon(50% 0%, 0% 100%, 100% 100%)' : 'none',
      }} />
      <span style={{ color: COLORS.textDim }}>{label}</span>
    </div>
  );
}

// --- Mount ---
ReactDOM.createRoot(document.getElementById('root')).render(<App />);
</script>
</body>
</html>
