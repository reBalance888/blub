<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>BLUB Ocean</title>
<script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
<script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
<script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body {
    background: #0a1628;
    color: #c8d6e5;
    font-family: 'Courier New', monospace;
    overflow: hidden;
    height: 100vh;
  }
  #root { height: 100vh; }
</style>
</head>
<body>
<div id="root"></div>
<script type="text/babel">
const { useState, useEffect, useRef, useCallback } = React;

// --- Agent type tags ---
const TYPE_TAG = { social: '(S)', greedy: '(G)', random: '(R)' };
const TYPE_COLOR = { social: '#7fdbca', greedy: '#ffd700', random: '#8395a7' };

// --- Colors ---
const COLORS = {
  bg: '#0a1628',
  ocean: '#0d1f3c',
  grid: 'rgba(0, 212, 255, 0.04)',
  rift: '#00d4ff',
  riftGlow: 'rgba(0, 212, 255, 0.3)',
  riftType: {
    gold: '#ffd700',
    silver: '#c0c0c0',
    copper: '#cd7f32',
  },
  predator: '#ff4757',
  sound: '#7fdbca',
  dead: 'rgba(120, 120, 120, 0.5)',
  panel: '#111d2e',
  panelBorder: '#1a2d45',
  text: '#c8d6e5',
  textDim: '#576574',
  accent: '#00d4ff',
  gold: '#ffd700',
  tier: {
    shrimp: '#8395a7',
    lobster: '#ee5a24',
    kraken: '#a55eea',
  },
};

// --- Main App ---
function App() {
  const [state, setState] = useState(null);
  const [connected, setConnected] = useState(false);
  const [soundLog, setSoundLog] = useState([]);
  const [selected, setSelected] = useState(null);
  const [floatingTexts, setFloatingTexts] = useState([]);
  const wsRef = useRef(null);
  const canvasRef = useRef(null);
  const floatIdRef = useRef(0);

  // WebSocket connection
  useEffect(() => {
    const connect = () => {
      const ws = new WebSocket(`ws://${location.hostname}:8000/ws/viewer`);
      wsRef.current = ws;

      ws.onopen = () => {
        setConnected(true);
        // Send a ping to keep alive
        ws.send('ping');
      };

      ws.onmessage = (e) => {
        try {
          const data = JSON.parse(e.data);
          setState(data);

          // Add sounds to log
          if (data.sounds && data.sounds.length > 0) {
            setSoundLog(prev => {
              const newEntries = data.sounds.map(s => ({
                tick: data.tick,
                from: s.from,
                sounds: s.sounds,
                key: `${data.tick}-${s.from}`,
              }));
              return [...newEntries, ...prev].slice(0, 50);
            });

            // Create floating texts for sounds
            setFloatingTexts(prev => {
              const newFloats = data.sounds.map(s => {
                const lob = data.lobsters.find(l => l.id === s.from);
                if (!lob) return null;
                floatIdRef.current++;
                return {
                  id: floatIdRef.current,
                  x: lob.pos[0],
                  y: lob.pos[1],
                  text: s.sounds.join(' '),
                  born: Date.now(),
                };
              }).filter(Boolean);
              // Remove old (> 2s)
              const now = Date.now();
              const alive = prev.filter(f => now - f.born < 2000);
              return [...alive, ...newFloats];
            });
          }
        } catch {}
      };

      ws.onclose = () => {
        setConnected(false);
        setTimeout(connect, 2000);
      };

      ws.onerror = () => ws.close();
    };

    connect();
    return () => wsRef.current?.close();
  }, []);

  // Canvas rendering
  useEffect(() => {
    if (!state || !canvasRef.current) return;
    const canvas = canvasRef.current;
    const ctx = canvas.getContext('2d');
    const W = canvas.width;
    const H = canvas.height;
    const SIZE = 100;
    const CELL = W / SIZE;

    // Clear
    ctx.fillStyle = COLORS.ocean;
    ctx.fillRect(0, 0, W, H);

    // Grid lines (subtle)
    ctx.strokeStyle = COLORS.grid;
    ctx.lineWidth = 0.5;
    for (let i = 0; i <= SIZE; i += 10) {
      ctx.beginPath();
      ctx.moveTo(i * CELL, 0);
      ctx.lineTo(i * CELL, H);
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(0, i * CELL);
      ctx.lineTo(W, i * CELL);
      ctx.stroke();
    }

    // Active zone boundary
    if (state.active_zone) {
      const az = state.active_zone;
      ctx.strokeStyle = 'rgba(0, 212, 255, 0.25)';
      ctx.lineWidth = 1.5;
      ctx.setLineDash([6, 4]);
      ctx.strokeRect(
        az.min * CELL,
        az.min * CELL,
        az.size * CELL,
        az.size * CELL
      );
      ctx.setLineDash([]);

      // Dim area outside active zone
      ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
      // Top strip
      ctx.fillRect(0, 0, W, az.min * CELL);
      // Bottom strip
      ctx.fillRect(0, (az.max + 1) * CELL, W, H - (az.max + 1) * CELL);
      // Left strip
      ctx.fillRect(0, az.min * CELL, az.min * CELL, az.size * CELL);
      // Right strip
      ctx.fillRect((az.max + 1) * CELL, az.min * CELL, W - (az.max + 1) * CELL, az.size * CELL);
    }

    // Communication lines (speaker â†’ listener)
    if (state.sound_lines && state.sound_lines.length > 0) {
      ctx.globalAlpha = 0.25;
      ctx.strokeStyle = COLORS.sound;
      ctx.lineWidth = 1;
      for (const line of state.sound_lines) {
        const x1 = line.from[0] * CELL + CELL / 2;
        const y1 = line.from[1] * CELL + CELL / 2;
        const x2 = line.to[0] * CELL + CELL / 2;
        const y2 = line.to[1] * CELL + CELL / 2;
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();
      }
      ctx.globalAlpha = 1;
    }

    // Rifts (pulsing circles, colored by type)
    const pulse = 0.8 + 0.2 * Math.sin(Date.now() / 500);
    for (const rift of state.rifts) {
      const rx = rift.pos[0] * CELL + CELL / 2;
      const ry = rift.pos[1] * CELL + CELL / 2;
      const baseR = 3 * CELL;
      const r = baseR * rift.richness_pct * pulse;
      const riftColor = COLORS.riftType[rift.rift_type] || COLORS.rift;

      // Glow
      const grad = ctx.createRadialGradient(rx, ry, 0, rx, ry, r);
      const rc = riftColor;
      grad.addColorStop(0, rc + '66');
      grad.addColorStop(0.5, rc + '26');
      grad.addColorStop(1, rc + '00');
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.arc(rx, ry, r, 0, Math.PI * 2);
      ctx.fill();

      // Core
      ctx.fillStyle = riftColor;
      ctx.beginPath();
      ctx.arc(rx, ry, CELL * 0.4, 0, Math.PI * 2);
      ctx.fill();
    }

    // Predators (red triangles)
    for (const pred of state.predators) {
      const px = pred.pos[0] * CELL + CELL / 2;
      const py = pred.pos[1] * CELL + CELL / 2;
      const s = CELL * 0.8;

      ctx.fillStyle = COLORS.predator;
      ctx.beginPath();
      ctx.moveTo(px, py - s);
      ctx.lineTo(px - s * 0.7, py + s * 0.5);
      ctx.lineTo(px + s * 0.7, py + s * 0.5);
      ctx.closePath();
      ctx.fill();

      // Glow
      ctx.shadowColor = COLORS.predator;
      ctx.shadowBlur = 8;
      ctx.fill();
      ctx.shadowBlur = 0;
    }

    // Lobsters
    for (const lob of state.lobsters) {
      const lx = lob.pos[0] * CELL + CELL / 2;
      const ly = lob.pos[1] * CELL + CELL / 2;
      const r = CELL * 0.45;

      if (!lob.alive) {
        ctx.fillStyle = COLORS.dead;
        ctx.globalAlpha = 0.4;
        ctx.beginPath();
        ctx.arc(lx, ly, r, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;
        continue;
      }

      const tierColor = COLORS.tier[lob.tier] || COLORS.tier.shrimp;
      ctx.fillStyle = tierColor;
      ctx.beginPath();
      ctx.arc(lx, ly, r, 0, Math.PI * 2);
      ctx.fill();

      // Grace shield (pulsing cyan ring)
      if (lob.grace) {
        const gPulse = 0.4 + 0.6 * Math.abs(Math.sin(Date.now() / 300));
        ctx.strokeStyle = `rgba(0, 212, 255, ${gPulse})`;
        ctx.lineWidth = 2;
        ctx.setLineDash([3, 3]);
        ctx.beginPath();
        ctx.arc(lx, ly, r + 4, 0, Math.PI * 2);
        ctx.stroke();
        ctx.setLineDash([]);
      }

      // Speaking indicator
      if (lob.speaking && lob.speaking.length > 0) {
        ctx.strokeStyle = COLORS.sound;
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.arc(lx, ly, r + (lob.grace ? 7 : 3), 0, Math.PI * 2);
        ctx.stroke();
      }

      // Selected highlight
      if (selected && selected.id === lob.id) {
        ctx.strokeStyle = COLORS.gold;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(lx, ly, r + 5, 0, Math.PI * 2);
        ctx.stroke();

        // Vision radius
        const tier = COLORS.tier[lob.tier] || COLORS.tier.shrimp;
        const vision = lob.tier === 'kraken' ? 25 : lob.tier === 'lobster' ? 12 : 5;
        ctx.strokeStyle = `${tier}44`;
        ctx.lineWidth = 1;
        ctx.setLineDash([4, 4]);
        ctx.beginPath();
        ctx.arc(lx, ly, vision * CELL, 0, Math.PI * 2);
        ctx.stroke();
        ctx.setLineDash([]);
      }
    }

    // Floating sound texts
    const now = Date.now();
    for (const ft of floatingTexts) {
      const age = now - ft.born;
      if (age > 2000) continue;
      const alpha = 1 - age / 2000;
      const fx = ft.x * CELL + CELL / 2;
      const fy = ft.y * CELL - 5 - (age / 100);

      ctx.fillStyle = `rgba(127, 219, 202, ${alpha})`;
      ctx.font = '10px Courier New';
      ctx.textAlign = 'center';
      ctx.fillText(ft.text, fx, fy);
    }
  }, [state, selected, floatingTexts]);

  // Animation loop for floating texts
  useEffect(() => {
    let raf;
    const animate = () => {
      if (state && canvasRef.current) {
        // Re-trigger render by updating floatingTexts age check
        setFloatingTexts(prev => {
          const now = Date.now();
          return prev.filter(f => now - f.born < 2000);
        });
      }
      raf = requestAnimationFrame(animate);
    };
    raf = requestAnimationFrame(animate);
    return () => cancelAnimationFrame(raf);
  }, [state]);

  // Click handler
  const handleCanvasClick = useCallback((e) => {
    if (!state) return;
    const canvas = canvasRef.current;
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    const mx = (e.clientX - rect.left) * scaleX;
    const my = (e.clientY - rect.top) * scaleY;
    const CELL = canvas.width / 100;

    let found = null;
    let minDist = Infinity;
    for (const lob of state.lobsters) {
      const lx = lob.pos[0] * CELL + CELL / 2;
      const ly = lob.pos[1] * CELL + CELL / 2;
      const d = Math.sqrt((mx - lx) ** 2 + (my - ly) ** 2);
      if (d < CELL * 2 && d < minDist) {
        minDist = d;
        found = lob;
      }
    }
    setSelected(found);
  }, [state]);

  if (!state) {
    return (
      <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', height: '100vh', color: COLORS.accent }}>
        <div style={{ textAlign: 'center' }}>
          <div style={{ fontSize: 48, marginBottom: 16 }}>BLUB</div>
          <div style={{ color: COLORS.textDim }}>
            {connected ? 'Waiting for data...' : 'Connecting to ocean...'}
          </div>
        </div>
      </div>
    );
  }

  const s = state.stats;
  const topLobsters = [...state.lobsters]
    .sort((a, b) => b.net_credits - a.net_credits)
    .slice(0, 10);

  return (
    <div style={{ display: 'flex', height: '100vh', gap: 0 }}>
      {/* Left: Ocean Canvas */}
      <div style={{ flex: 1, display: 'flex', flexDirection: 'column', minWidth: 0 }}>
        <canvas
          ref={canvasRef}
          width={700}
          height={700}
          onClick={handleCanvasClick}
          style={{
            flex: 1,
            width: '100%',
            maxHeight: 'calc(100vh - 160px)',
            cursor: 'crosshair',
            imageRendering: 'pixelated',
          }}
        />
        {/* Sound log */}
        <div style={{
          height: 160,
          background: COLORS.panel,
          borderTop: `1px solid ${COLORS.panelBorder}`,
          overflowY: 'auto',
          padding: '8px 12px',
          fontSize: 12,
        }}>
          <div style={{ color: COLORS.textDim, marginBottom: 4, fontWeight: 'bold' }}>
            SOUND LOG
          </div>
          {soundLog.map(entry => (
            <div key={entry.key} style={{ marginBottom: 2, lineHeight: 1.4 }}>
              <span style={{ color: COLORS.textDim }}>[{entry.tick}]</span>{' '}
              <span style={{ color: COLORS.accent }}>{entry.from}</span>:{' '}
              <span style={{ color: COLORS.sound }}>"{entry.sounds.join(' ')}"</span>
            </div>
          ))}
          {soundLog.length === 0 && (
            <div style={{ color: COLORS.textDim, fontStyle: 'italic' }}>No sounds yet...</div>
          )}
        </div>
      </div>

      {/* Right: Stats Panel */}
      <div style={{
        width: 280,
        background: COLORS.panel,
        borderLeft: `1px solid ${COLORS.panelBorder}`,
        padding: 16,
        overflowY: 'auto',
        display: 'flex',
        flexDirection: 'column',
        gap: 16,
      }}>
        {/* Header */}
        <div>
          <div style={{ fontSize: 24, fontWeight: 'bold', color: COLORS.accent, letterSpacing: 4 }}>
            BLUB
          </div>
          <div style={{ color: COLORS.textDim, fontSize: 11 }}>OCEAN SIMULATION</div>
        </div>

        {/* Epoch info */}
        <Panel title="EPOCH">
          <Row label="Tick" value={state.tick} />
          <Row label="Epoch" value={state.epoch} />
          <Row label="Remaining" value={state.epoch_ticks_remaining} />
          <Row label="Epoch Pool" value={`${(s.epoch_pool || 0).toLocaleString()} BLUB`} color={COLORS.gold} />
        </Panel>

        {/* World stats */}
        <Panel title="WORLD">
          <Row label="Active Zone" value={state.active_zone ? `${state.active_zone.size}x${state.active_zone.size}` : '?'} color={COLORS.accent} />
          <Row label="Lobsters" value={`${s.alive_lobsters} / ${s.total_lobsters}`} />
          <Row label="Active Rifts" value={s.active_rifts} color={COLORS.rift} />
          <Row label="Predators" value={state.predators.length} color={state.predators.length > 0 ? COLORS.predator : COLORS.text} />
          <Row label="Credits Earned" value={s.total_credits_earned?.toLocaleString()} />
          <Row label="Credits on Sounds" value={s.total_credits_spent_on_sounds?.toLocaleString()} />
        </Panel>

        {/* Metrics */}
        {state.metrics && state.metrics.tick && (
          <Panel title="LANGUAGE METRICS">
            <Row label="Vocabulary" value={state.metrics.vocabulary_size} color={COLORS.accent} />
            <Row label="TopSim" value={state.metrics.top_sim?.toFixed(3)} color={state.metrics.top_sim > 0.3 ? '#2ed573' : COLORS.text} />
            <Row label="PosDis" value={state.metrics.pos_dis?.toFixed(3)} color={state.metrics.pos_dis > 0.2 ? '#2ed573' : COLORS.text} />
            <Row label="MI" value={state.metrics.mutual_info?.toFixed(3)} color={state.metrics.mutual_info > 0.5 ? '#2ed573' : COLORS.text} />
            <Row label="Econ Delta" value={state.metrics.economic_delta?.toFixed(1)} color={state.metrics.economic_delta > 0 ? '#2ed573' : COLORS.predator} />
            <div style={{ fontSize: 8, color: COLORS.textDim, marginTop: 4, textAlign: 'center' }}>
              updated every 100 ticks
            </div>
          </Panel>
        )}

        {/* Leaderboard */}
        <Panel title="LEADERBOARD">
          {topLobsters.map((lob, i) => (
            <div
              key={lob.id}
              style={{
                display: 'flex',
                justifyContent: 'space-between',
                padding: '3px 0',
                cursor: 'pointer',
                color: selected?.id === lob.id ? COLORS.gold : COLORS.text,
                opacity: lob.alive ? 1 : 0.4,
              }}
              onClick={() => setSelected(lob)}
            >
              <span>
                <span style={{ color: COLORS.textDim }}>#{i + 1}</span>{' '}
                <span style={{ color: COLORS.tier[lob.tier] || COLORS.tier.shrimp }}>
                  {lob.id}
                </span>{' '}
                {lob.agent_type && (
                  <span style={{ color: TYPE_COLOR[lob.agent_type] || COLORS.textDim, fontSize: 10 }}>
                    {TYPE_TAG[lob.agent_type] || ''}
                  </span>
                )}
              </span>
              <span style={{ color: COLORS.accent }}>{lob.net_credits.toFixed(1)}</span>
            </div>
          ))}
        </Panel>

        {/* Last epoch top earner */}
        {s.last_epoch_top_earner && s.last_epoch_top_earner.id && (
          <Panel title="LAST EPOCH WINNER">
            <Row label="Agent" value={s.last_epoch_top_earner.id} color={COLORS.gold} />
            <Row label="Reward" value={`${s.last_epoch_top_earner.reward.toLocaleString()} BLUB`} color={COLORS.gold} />
          </Panel>
        )}

        {/* Emergent Dictionary */}
        {state.emergent_dictionary && state.emergent_dictionary.length > 0 && (
          <Panel title="EMERGENT DICTIONARY">
            <div style={{ fontSize: 10 }}>
              {state.emergent_dictionary.slice(0, 12).map(entry => {
                const barWidth = Math.round(entry.confidence * 100);
                const meaningColor = entry.meaning === 'near_rift' ? COLORS.rift
                  : entry.meaning === 'danger' ? COLORS.predator
                  : entry.meaning === 'crowded' ? COLORS.gold
                  : COLORS.textDim;
                return (
                  <div key={entry.sound} style={{ marginBottom: 3 }}>
                    <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                      <span style={{ color: COLORS.sound, fontWeight: 'bold' }}>{entry.sound}</span>
                      <span style={{ color: meaningColor, fontSize: 9 }}>{entry.meaning}</span>
                    </div>
                    <div style={{ display: 'flex', alignItems: 'center', gap: 4 }}>
                      <div style={{
                        flex: 1, height: 3, background: COLORS.panelBorder, borderRadius: 2,
                      }}>
                        <div style={{
                          width: `${barWidth}%`, height: '100%', borderRadius: 2,
                          background: meaningColor,
                          opacity: 0.7,
                        }} />
                      </div>
                      <span style={{ color: COLORS.textDim, fontSize: 8, minWidth: 28, textAlign: 'right' }}>
                        {Math.round(entry.confidence * 100)}%
                      </span>
                    </div>
                  </div>
                );
              })}
              <div style={{ color: COLORS.textDim, fontSize: 8, marginTop: 4, textAlign: 'center' }}>
                server-side ground truth correlations
              </div>
            </div>
          </Panel>
        )}

        {/* Epoch Chart (SVG line chart S vs G vs R) */}
        {state.epoch_history && state.epoch_history.length >= 2 && (
          <Panel title="EPOCH REWARDS">
            {(() => {
              const data = state.epoch_history;
              const W = 240, H = 80, PAD = 20;
              const plotW = W - PAD * 2, plotH = H - PAD;
              const maxVal = Math.max(...data.flatMap(d =>
                ['social','greedy','random'].map(t => d.types[t]?.total_reward || 0)
              ));
              const xStep = data.length > 1 ? plotW / (data.length - 1) : 0;

              const makeLine = (type) => {
                return data.map((d, i) => {
                  const v = d.types[type]?.total_reward || 0;
                  const x = PAD + i * xStep;
                  const y = PAD + plotH - (maxVal > 0 ? (v / maxVal) * plotH : 0);
                  return `${x},${y}`;
                }).join(' ');
              };

              const fmt = (v) => v >= 1000000 ? `${(v/1000000).toFixed(1)}M` : v >= 1000 ? `${(v/1000).toFixed(0)}k` : v;

              return (
                <svg width={W} height={H} style={{ display: 'block' }}>
                  {/* Grid lines */}
                  <line x1={PAD} y1={PAD} x2={PAD} y2={H} stroke={COLORS.panelBorder} strokeWidth="1" />
                  <line x1={PAD} y1={H} x2={W - PAD} y2={H} stroke={COLORS.panelBorder} strokeWidth="1" />
                  {/* Max value label */}
                  <text x={PAD - 2} y={PAD + 4} fill={COLORS.textDim} fontSize="7" textAnchor="end">{fmt(maxVal)}</text>
                  <text x={PAD - 2} y={H} fill={COLORS.textDim} fontSize="7" textAnchor="end">0</text>

                  {/* Lines */}
                  <polyline points={makeLine('social')} fill="none" stroke={TYPE_COLOR.social} strokeWidth="2" />
                  <polyline points={makeLine('greedy')} fill="none" stroke={TYPE_COLOR.greedy} strokeWidth="2" strokeDasharray="4 2" />
                  <polyline points={makeLine('random')} fill="none" stroke={TYPE_COLOR.random} strokeWidth="1.5" strokeDasharray="2 2" />

                  {/* Dots for last epoch */}
                  {['social','greedy','random'].map(type => {
                    const lastIdx = data.length - 1;
                    const v = data[lastIdx].types[type]?.total_reward || 0;
                    const x = PAD + lastIdx * xStep;
                    const y = PAD + plotH - (maxVal > 0 ? (v / maxVal) * plotH : 0);
                    return <circle key={type} cx={x} cy={y} r="3" fill={TYPE_COLOR[type]} />;
                  })}

                  {/* Epoch labels */}
                  {data.map((d, i) => (
                    <text key={i} x={PAD + i * xStep} y={H + 1} fill={COLORS.textDim} fontSize="7" textAnchor="middle">
                      {d.epoch}
                    </text>
                  ))}
                </svg>
              );
            })()}
            {/* Compact legend */}
            <div style={{ display: 'flex', gap: 8, justifyContent: 'center', marginTop: 2 }}>
              {[['S', TYPE_COLOR.social], ['G', TYPE_COLOR.greedy], ['R', TYPE_COLOR.random]].map(([label, color]) => (
                <span key={label} style={{ fontSize: 9, color }}>{label}</span>
              ))}
            </div>
          </Panel>
        )}

        {/* Epoch History Table */}
        {state.epoch_history && state.epoch_history.length > 0 && (
          <Panel title="EPOCH HISTORY">
            <div style={{ fontSize: 10, overflowX: 'auto' }}>
              <table style={{ width: '100%', borderCollapse: 'collapse', fontSize: 10 }}>
                <thead>
                  <tr style={{ borderBottom: `1px solid ${COLORS.panelBorder}` }}>
                    <th style={{ textAlign: 'left', padding: '2px 4px', color: COLORS.textDim }}>E</th>
                    <th style={{ textAlign: 'right', padding: '2px 4px', color: TYPE_COLOR.social }}>S</th>
                    <th style={{ textAlign: 'right', padding: '2px 4px', color: TYPE_COLOR.greedy }}>G</th>
                    <th style={{ textAlign: 'right', padding: '2px 4px', color: TYPE_COLOR.random }}>R</th>
                  </tr>
                </thead>
                <tbody>
                  {state.epoch_history.map(eh => {
                    const s = eh.types.social;
                    const g = eh.types.greedy;
                    const r = eh.types.random;
                    const maxReward = Math.max(s?.total_reward || 0, g?.total_reward || 0, r?.total_reward || 0);
                    const fmt = (v) => v >= 1000 ? `${(v/1000).toFixed(0)}k` : v;
                    return (
                      <tr key={eh.epoch} style={{ borderBottom: `1px solid ${COLORS.panelBorder}22` }}>
                        <td style={{ padding: '2px 4px', color: COLORS.textDim }}>{eh.epoch}</td>
                        <td style={{ textAlign: 'right', padding: '2px 4px', color: TYPE_COLOR.social, fontWeight: s && s.total_reward === maxReward ? 'bold' : 'normal' }}>
                          {s ? fmt(s.total_reward) : '-'}
                        </td>
                        <td style={{ textAlign: 'right', padding: '2px 4px', color: TYPE_COLOR.greedy, fontWeight: g && g.total_reward === maxReward ? 'bold' : 'normal' }}>
                          {g ? fmt(g.total_reward) : '-'}
                        </td>
                        <td style={{ textAlign: 'right', padding: '2px 4px', color: TYPE_COLOR.random, fontWeight: r && r.total_reward === maxReward ? 'bold' : 'normal' }}>
                          {r ? fmt(r.total_reward) : '-'}
                        </td>
                      </tr>
                    );
                  })}
                </tbody>
              </table>
              {/* Group hits comparison for last epoch */}
              {(() => {
                const last = state.epoch_history[state.epoch_history.length - 1];
                if (!last) return null;
                const types = ['social', 'greedy', 'random'];
                return (
                  <div style={{ marginTop: 6, borderTop: `1px solid ${COLORS.panelBorder}`, paddingTop: 4 }}>
                    <div style={{ color: COLORS.textDim, marginBottom: 2 }}>Last epoch details:</div>
                    {types.map(t => {
                      const d = last.types[t];
                      if (!d) return null;
                      return (
                        <div key={t} style={{ display: 'flex', justifyContent: 'space-between', padding: '1px 0' }}>
                          <span style={{ color: TYPE_COLOR[t] }}>{t}</span>
                          <span style={{ color: COLORS.textDim }}>
                            grp:{d.group_hits} deaths:{d.deaths}
                          </span>
                        </div>
                      );
                    })}
                  </div>
                );
              })()}
            </div>
          </Panel>
        )}

        {/* Selected lobster info */}
        {selected && (
          <Panel title={`SELECTED: ${selected.id}`}>
            <Row label="Name" value={selected.name} />
            <Row label="Position" value={`(${selected.pos[0]}, ${selected.pos[1]})`} />
            <Row label="Tier" value={selected.tier} color={COLORS.tier[selected.tier]} />
            <Row label="Net Credits" value={selected.net_credits.toFixed(2)} color={COLORS.accent} />
            <Row label="Alive" value={selected.alive ? 'YES' : 'DEAD'} color={selected.alive ? '#2ed573' : COLORS.predator} />
            {selected.grace && (
              <Row label="Shield" value="ACTIVE" color={COLORS.accent} />
            )}
            {selected.agent_type && (
              <Row label="Type" value={selected.agent_type} color={TYPE_COLOR[selected.agent_type]} />
            )}
            {selected.speaking && selected.speaking.length > 0 && (
              <Row label="Speaking" value={selected.speaking.join(' ')} color={COLORS.sound} />
            )}
          </Panel>
        )}

        {/* Legend */}
        <Panel title="LEGEND">
          <LegendItem color={COLORS.tier.shrimp} label="Shrimp (vision 5)" />
          <LegendItem color={COLORS.tier.lobster} label="Lobster (vision 12)" />
          <LegendItem color={COLORS.tier.kraken} label="Kraken (vision 25)" />
          <LegendItem color={COLORS.riftType.gold} label="Gold rift" shape="circle" />
          <LegendItem color={COLORS.riftType.silver} label="Silver rift" shape="circle" />
          <LegendItem color={COLORS.riftType.copper} label="Copper rift" shape="circle" />
          <LegendItem color={COLORS.predator} label="Predator" shape="triangle" />
          <LegendItem color={COLORS.accent} label="Grace shield (immune)" shape="circle" />
          <div style={{ marginTop: 4, borderTop: `1px solid ${COLORS.panelBorder}`, paddingTop: 4 }}>
            <LegendItem color={TYPE_COLOR.social} label="(S) Social" />
            <LegendItem color={TYPE_COLOR.greedy} label="(G) Greedy" />
            <LegendItem color={TYPE_COLOR.random} label="(R) Random" />
          </div>
        </Panel>

        {/* Connection status */}
        <div style={{ fontSize: 10, color: COLORS.textDim, marginTop: 'auto' }}>
          <span style={{ color: connected ? '#2ed573' : COLORS.predator }}>
            {connected ? '\u25CF' : '\u25CB'}
          </span>{' '}
          {connected ? 'Connected' : 'Disconnected'}
        </div>
      </div>
    </div>
  );
}

// --- Reusable Components ---
function Panel({ title, children }) {
  return (
    <div style={{
      background: 'rgba(255,255,255,0.03)',
      border: `1px solid ${COLORS.panelBorder}`,
      borderRadius: 6,
      padding: '10px 12px',
    }}>
      <div style={{
        fontSize: 10,
        fontWeight: 'bold',
        color: COLORS.textDim,
        marginBottom: 6,
        letterSpacing: 1,
      }}>
        {title}
      </div>
      {children}
    </div>
  );
}

function Row({ label, value, color }) {
  return (
    <div style={{
      display: 'flex',
      justifyContent: 'space-between',
      fontSize: 12,
      padding: '2px 0',
    }}>
      <span style={{ color: COLORS.textDim }}>{label}</span>
      <span style={{ color: color || COLORS.text }}>{value}</span>
    </div>
  );
}

function LegendItem({ color, label, shape }) {
  return (
    <div style={{ display: 'flex', alignItems: 'center', gap: 6, fontSize: 11, padding: '1px 0' }}>
      <span style={{
        display: 'inline-block',
        width: 8,
        height: 8,
        background: color,
        borderRadius: shape === 'triangle' ? 0 : '50%',
        clipPath: shape === 'triangle' ? 'polygon(50% 0%, 0% 100%, 100% 100%)' : 'none',
      }} />
      <span style={{ color: COLORS.textDim }}>{label}</span>
    </div>
  );
}

// --- Mount ---
ReactDOM.createRoot(document.getElementById('root')).render(<App />);
</script>
</body>
</html>
